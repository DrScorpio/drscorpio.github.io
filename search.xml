<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rust-引用与借用</title>
    <url>/2024/02/27/Rust-Borrowing/</url>
    <content><![CDATA[<blockquote>
<p><strong>系列文章</strong></p>
<ol><li><a href="/2024/02/27/Rust-Borrowing/" title="Rust-引用与借用">Rust-引用与借用</a></li><li><a href="/2024/02/28/rust-match/" title="Rust-枚举和Match匹配">Rust-枚举和Match匹配</a></li></ol>
</blockquote>
<p>在<a href="https://blog.drscorpio.site/2024/02/22/using-rustling/">上一篇文章</a>中，我们开始使用Rustling来学习Rust语言，本文我们将探讨在学习过程中遇到的第一个难点 <strong>引用与借用</strong></p>
<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>在Rustling的<code>move_semantics6</code>练习中我们将接触到Rust语言与其他编程语言最大的差异，<strong>引用和借用</strong><br>让我们首先来看看题目：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;Rust is great!&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">get_char</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">string_uppercase</span>(&amp;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Should not take ownership</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_char</span>(data: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    data.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Should take ownership</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">string_uppercase</span>(<span class="keyword">mut</span> data: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    data = &amp;data.<span class="title function_ invoke__">to_uppercase</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>ps:题目中删除了一些不必要的注释，因为他们不重要</em></p>
</blockquote>
<p>在声明的两个函数中，我们需要对参数字符串进行不同的操作，其中:  </p>
<ul>
<li><code>get_char()</code>，要求我们返回字符串的最后一个字符</li>
<li><code>string_uppercase()</code>要求我们将字符串转换为全大写字符<br>从函数效果来看，不难发现，<code>get_char()</code>函数不需要我们对传入的参数进行修改，而<code>string_uppercase()</code>需要我们对传入的参数进行修改。</li>
</ul>
<p>在<code>main()</code>函数中，我们声明了一个变量<code>data</code>，并将字符串<code>&quot;Rust is Great!&quot;</code><del>雀食</del>赋给了它，随后我们使用声明的两个函数<code>get_char()</code>，和<code>string_uppercase()</code>对这个变量进行操作。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当我们运行这段代码的时候，出现了一点<del>小小的</del>问题，rustup告诉我们：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">error[<span class="type">E0382</span>]: borrow of moved value: `data`</span><br><span class="line">  <span class="literal">--</span>&gt; exercises/move_semantics/move_semantics6.rs:<span class="number">15</span>:<span class="number">22</span></span><br><span class="line"><span class="number">13</span> |     get_char(<span class="keyword">data</span>);</span><br><span class="line">   |              <span class="literal">----</span> value moved here</span><br><span class="line"><span class="number">14</span> |</span><br><span class="line"><span class="number">15</span> |     string_uppercase(&amp;<span class="keyword">data</span>);</span><br><span class="line">   |                      ^^^^^ value borrowed here after <span class="built_in">move</span></span><br><span class="line">error[<span class="type">E0716</span>]: temporary value dropped <span class="keyword">while</span> borrowed</span><br><span class="line">error: aborting due to <span class="number">2</span> previous errors</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>这里省略了一些输出，因为虽然他们很有用，但是放在文章阅读就不太友好了</em></p>
</blockquote>
<h2 id="原因与解决方案"><a href="#原因与解决方案" class="headerlink" title="原因与解决方案"></a>原因与解决方案</h2><p>上文两个error其实都是一个原因导致的：  </p>
<ol>
<li>我们先将<code>data</code>的所有权交给了<code>get_char()</code>函数  </li>
<li>然后又将<code>data</code>借用给了<code>string_uppercase()</code></li>
</ol>
<p>在<code>get_char</code>函数运行时，<code>data</code>的所有权已经转移给了它，待函数结束之后，<code>data</code>已经移出了作用域，所以后续的<code>string_uppercase()</code>就无法在借用<code>data</code>的值了</p>
<p>当然，我们的解决方法也很简单，根据注释来修改这两个函数的传入参数就可以了。<br>因为在<code>get_char()</code>中，我们不需要修改参数的值，所以这里应该传入的是一个借用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_char</span>(data: &amp;<span class="type">String</span><span class="comment">/*这里修改为借用*/</span>) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    data.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在<code>string_uppercase()</code>中，我们需要修改参数的值，所以这里应该获得参数的所有权</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">string_uppercase</span>(<span class="keyword">mut</span> data: <span class="type">String</span><span class="comment">/*这里删除&amp;*/</span>) &#123;</span><br><span class="line">    data = data.<span class="title function_ invoke__">to_uppercase</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再修改一下<code>main</code>就大功告成了<br>完整代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;Rust is great!&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">get_char</span>(&amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">string_uppercase</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Should not take ownership</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_char</span>(data: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    data.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Should take ownership</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">string_uppercase</span>(<span class="keyword">mut</span> data: <span class="type">String</span>) &#123;</span><br><span class="line">    data = data.<span class="title function_ invoke__">to_uppercase</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>复活！</title>
    <url>/2024/02/21/NewStart/</url>
    <content><![CDATA[<p>原身，启动！</p>
<p>努力重建博客中…</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>什么玩意儿</tag>
      </tags>
  </entry>
  <entry>
    <title>初试Rustlings-Rustlings安装部署和尝试</title>
    <url>/2024/02/22/using-rustling/</url>
    <content><![CDATA[<p><strong>今天在互联网闲逛的时候无意中发现了Rustlings这个项目，刚好最近有在打算学习Rust，于是抱着试试的心态尝试了一下</strong></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>推荐使用<a href="https://rustlings.cool/">官网</a>的手动安装方法</p>
<ol>
<li>Clone官方的仓库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find out the latest version at https://github.com/rust-lang/rustlings/releases/latest (on edit 5.6.1)</span></span><br><span class="line">git <span class="built_in">clone</span> -b 5.6.1 --depth 1 https://github.com/rust-lang/rustlings</span><br><span class="line"><span class="built_in">cd</span> rustings</span><br></pre></td></tr></table></figure></li>
<li>用cargo安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo install --force --path .</span><br></pre></td></tr></table></figure></li>
<li>最后运行rustup <del>建议挂梯子，否则可能非常漫长</del><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustup update</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>官方文档给出了具体的命令，详情查阅<a href="https://rustlings.cool/">官网</a>下的Doing exercises部分</p>
<ol>
<li>在安装目录下打开终端，输入<code>rustlings watch</code>启动Rustlings,本人这里使用了VScode内置的终端来方便使用<br><img src="https://picture-bed-1258433330.cos.ap-nanjing.myqcloud.com/img/blog/20240222145316.png"></li>
<li>根据命令行提示完成对应练习，练习用的rs文件在目录下的<code>/exercises/</code>文件夹内，rustlings在检测到文件变动后会自动编译检查。</li>
<li>完成练习后删除注释中的<code>I AM NOT DONE</code>来进行下一个练习</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前本人只是简单完成了2、3个练习内容，后续的进度也会在博客中及时更新 <del>大概</del></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust-枚举和Match匹配</title>
    <url>/2024/02/28/rust-match/</url>
    <content><![CDATA[<blockquote>
<p><strong>系列文章</strong>  </p>
<ol><li><a href="/2024/02/27/Rust-Borrowing/" title="Rust-引用与借用">Rust-引用与借用</a></li><li><a href="/2024/02/28/rust-match/" title="Rust-枚举和Match匹配">Rust-枚举和Match匹配</a></li></ol>
</blockquote>
<p>在<a href="https://blog.drscorpio.site/2024/02/27/Rust-Borrowing/">上一篇</a>文章里，我们探讨了Rust中的一个重要概念——引用和借用。在这篇文章中，我们将继续探讨本人在通过Rustling学习Rust中遇到的第二个问题——枚举(Enum)和模式匹配(Match)</p>
<h2 id="枚举（Enum）"><a href="#枚举（Enum）" class="headerlink" title="枚举（Enum）"></a>枚举（Enum）</h2><p>枚举通过关键字<code>enum</code>来声明，通过<code>enum</code>关键字我们可以声明一个指定的<strong>枚举类型</strong>。<br>比如在<em>Rust圣经</em>中的一个例子:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PokerSuit</span>&#123;</span><br><span class="line">    Clubs,</span><br><span class="line">    Spades,</span><br><span class="line">    Diamonds,</span><br><span class="line">    Hearts,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们声明了一个<strong>枚举类型</strong><code>PockerSuit</code>,其中包含了4种<strong>枚举值</strong>:<code>Clubs</code>,<code>Spades</code>,<code>Diamonds</code>,<code>Hearts</code>。之后，我们便可以使用它们了，比如我们可以创建两个<code>PockerSuit</code>类型的成员实例：  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> <span class="variable">heart</span> = PokerSuit::Heart;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">clubs</span> = PokerSuit::Clubs;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">与其他语言不同,Rust可以将不同的数据类型直接关联到枚举成员上，例如我们给上文的扑克花色关联上具体的点数大小:    </span><br><span class="line">```rust</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">PokerSuit</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">Clubs</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Spades</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Diamonds</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hearts</span>(<span class="type">u8</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们便可以给枚举类型的成员实例附上值了，<del>这可比golang好用多了</del>： </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">d12</span> = PockerSuit::<span class="title function_ invoke__">Diamonds</span>(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s13</span> = PockerSuit::<span class="title function_ invoke__">Spades</span>(<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<p>当然，我们可不满足于此，对于同一<strong>枚举类型</strong>的不同的枚举成员，我们还可以给他关联上不同的数据类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">Str</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Num</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="type">bool</span>),</span><br><span class="line">    <span class="title function_ invoke__">Tuple</span>(<span class="type">i32</span>,<span class="type">String</span>,<span class="type">bool</span>)<span class="comment">//这里关联了个元组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们甚至可以关联结构体或其他枚举类型：  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//enum</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">PokerSuit</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">Clubs</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Spades</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Diamonds</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hearts</span>(<span class="type">u8</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Poker</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">Suit</span>(PokerSuit),</span><br><span class="line">    <span class="title function_ invoke__">Flip</span>(<span class="type">bool</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArmedHelicopter</span>&#123;</span><br><span class="line">    Missile:<span class="type">String</span>,</span><br><span class="line">    Type:<span class="type">String</span>,</span><br><span class="line">    Pilot:<span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">Male</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">FeMale</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Other</span>(ArmedHelicopter),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>真是强而有力，强而有力啊</del>  </p>
<h2 id="Match——匹配"><a href="#Match——匹配" class="headerlink" title="Match——匹配"></a>Match——匹配</h2><p>当我们成功声明了一个枚举类型之后可能会遇到一个问题：如何处理同一<strong>枚举类型</strong>下的不同<strong>枚举值</strong>？它们可能对应的是<strong>不同的数据类型</strong>。<br>幸运的是，Rust给我们提供了模式匹配来方便我们对不同的枚举值进行处理，本文我们先探讨第一种模式匹配方法——<code>match</code>  </p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>我们首先来看看match的通用形式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> target &#123;</span><br><span class="line">    模式<span class="number">1</span> =&gt; 表达式<span class="number">1</span>,</span><br><span class="line">    模式<span class="number">2</span> =&gt; &#123;</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        表达式<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _ =&gt; 表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意：</p>
<ul>
<li><code>match</code>的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同。</li>
<li><code>match</code>的匹配必须要穷举出所有可能，这里使用<code>_</code>来匹配除了<strong>模式1</strong>和<strong>模式2</strong>以外的其他所有情况</li>
<li>匹配的模式可以使用<code>|</code>来表示逻辑运算中的<strong>或</strong>，从而匹配多种模式，例如<code>模式3 | 模式4 =&gt; 表达式foo，</code></li>
</ul>
<div class="note warning flat"><p>注意！这里只能使用<code>|</code>，不能使用<code>||</code>、<code>&amp;&amp;</code>、<code>!</code>等逻辑运算符，<code>match</code>的模式匹配中每个匹配臂（arm）的模式必须是独立的，如果想要更复杂的匹配方式，需要添加<strong>匹配守卫(Pattern guard)<strong>，来进一步改进匹配标准,关于</strong>匹配守卫</strong>，我们<del>应该</del>会在后面的文章中进一步探讨。</p>
</div>  
<p>这里展示一个简单的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PokerSuit</span>&#123;</span><br><span class="line">    Clubs,</span><br><span class="line">    Spades,</span><br><span class="line">    Diamonds,</span><br><span class="line">    Hearts,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show_poker_suit</span>(suit:PokerSuit) <span class="punctuation">-&gt;</span> <span class="type">char</span>&#123;</span><br><span class="line">    <span class="keyword">match</span> suit &#123;</span><br><span class="line">        PokerSuit::Clubs =&gt; <span class="string">&#x27;♣&#x27;</span>,</span><br><span class="line">        PokerSuit::Heart =&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;♥!&quot;</span>);</span><br><span class="line">            <span class="string">&#x27;♥&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        PokerSuit::Spades =&gt;<span class="string">&#x27;♠&#x27;</span>,</span><br><span class="line">        PokerSuit::Diamonds =&gt;<span class="string">&#x27;♦&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用match表达式赋值"><a href="#使用match表达式赋值" class="headerlink" title="使用match表达式赋值"></a>使用match表达式赋值</h3><p><code>match</code> 本身也是一个表达式，因此可以用它来赋值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//偷了一个Rust圣经的例子</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">   Ipv4,</span><br><span class="line">   Ipv6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip1</span> = IpAddr::Ipv6;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip_str</span> = <span class="keyword">match</span> ip1 &#123;</span><br><span class="line">        IpAddr::Ipv4 =&gt; <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="string">&quot;::1&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ip_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里匹配到<code>_</code>分支，所以将<code>&quot;::1&quot;</code> 赋值给了<code>ip_str</code>。  </p>
<h3 id="模式绑定"><a href="#模式绑定" class="headerlink" title="模式绑定"></a>模式绑定</h3><p>终于来到了重头戏<del>（这篇文章就是为了这个而生的）</del>，<code>match</code>的一个重要功能就是从模式中取出绑定的值，例如我们在<strong>枚举</strong>中举的一个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">Str</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Num</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="type">bool</span>),</span><br><span class="line">    <span class="title function_ invoke__">Tuple</span>(<span class="type">i32</span>,<span class="type">String</span>,<span class="type">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show_message</span>(msg Message) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::<span class="title function_ invoke__">Str</span>(strmsg) =&gt; strmsg,<span class="comment">//这里将Str存储的字符串类型的值绑定在了变量strmsg上</span></span><br><span class="line">        Message::<span class="title function_ invoke__">Num</span>(nummsg) =&gt; nummsg.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        Message::<span class="title function_ invoke__">Ok</span>(okmsg) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,okmsg),</span><br><span class="line">        Message::<span class="title function_ invoke__">Tuple</span>(x,y,z) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>,x,y,z)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="穷尽匹配"><a href="#穷尽匹配" class="headerlink" title="穷尽匹配"></a>穷尽匹配</h3><p>简单来说，如果你在<code>match</code>中没有列出所有可能的匹配情况，rustup会报错 <del>Rustup：写的什么垃圾代码，你给我去屎吧</del>  </p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="_通配符"></a>_通配符</h3><p>当我们不想在匹配时列出所有值的时候，可以使用 Rust 提供的一个特殊模式<code>_</code>通配符，比如我们的函数只关心<code>PokerSuit</code>中的红牌：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">show_me_red</span>(suit:PokerSuit) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">match</span> suit &#123;</span><br><span class="line">        PokerSuit::Hearts =&gt; <span class="string">&quot;I got ♥ !&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        PokerSuit::Diamonds =&gt; <span class="string">&quot;I got ♦!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        _ =&gt; <span class="string">&quot;I got smoke :( &quot;</span>.<span class="title function_ invoke__">to_string</span>()<span class="comment">//吸烟有害健康</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，除了<code>_</code>，我们也可以用其他变量来承载其他情况：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">show_me_red</span>(suit:PokerSuit) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">match</span> suit &#123;</span><br><span class="line">        PokerSuit::Hearts =&gt; <span class="string">&quot;I got ♥ !&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        PokerSuit::Diamonds =&gt; <span class="string">&quot;I got ♦!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        other =&gt; <span class="built_in">format!</span>(<span class="string">&quot;I got &#123;:#?&#125;&quot;</span>,other),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rust提供了强大的枚举和<code>match</code>匹配来使得我们的代码更加简洁美观，让我们可以摆脱丑陋的<code>if else</code>，在后面的文章里<del>（如果有的话）</del>，我们会进一步探讨其他的模式匹配方法，以及之前提到的匹配守卫(Pattern guard)。    </p>
<blockquote><p>部分内容引用自Rust语言圣经(Rust Course)</p>
<footer><strong>Rust语言圣经(Rust Course)</strong><cite><a href="https://github.com/sunface/rust-course">github.com/sunface/rust-course</a></cite></footer></blockquote>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>学习笔记</tag>
        <tag>Rust模式匹配</tag>
      </tags>
  </entry>
</search>
